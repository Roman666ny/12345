Выполнил Дементеев Роман УИБО-10-24

## 1. Блочная (корзинная) сортировка

### Определение
Блочная сортировка распределяет элементы массива на несколько блоков (корзин) в зависимости от диапазона их значений, затем сортирует каждую корзину отдельно и объединяет их.

### Код
```python
def bucket_sort(arr):
    """
    Блочная (корзинная) сортировка
    """
    if len(arr) == 0:
        return arr
    
    # Определяем количество корзин
    n = len(arr)
    max_val = max(arr)
    min_val = min(arr)
    bucket_range = (max_val - min_val) / n if max_val != min_val else 1
    
    # Создаем корзины
    buckets = [[] for _ in range(n + 1)]
    
    # Распределяем элементы по корзинам
    for num in arr:
        index = int((num - min_val) / bucket_range)
        if index == n:  # Обработка граничного случая
            index = n - 1
        buckets[index].append(num)
    
    # Сортируем каждую корзину и объединяем
    result = []
    for bucket in buckets:
        # Используем сортировку вставками для каждой корзины
        for i in range(1, len(bucket)):
            key = bucket[i]
            j = i - 1
            while j >= 0 and bucket[j] > key:
                bucket[j + 1] = bucket[j]
                j -= 1
            bucket[j + 1] = key
        result.extend(bucket)
    
    return result

# Тестирование
if __name__ == "__main__":
    test_array = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
    print("Исходный массив:", test_array)
    sorted_array = bucket_sort(test_array)
    print("Отсортированный массив:", sorted_array)
```

### Результат выдачи
```
Исходный массив: [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
Отсортированный массив: [0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
```

### Принцип работы алгоритма
1. Определяется диапазон значений и количество корзин
2. Каждый элемент помещается в соответствующую корзину
3. Каждая корзина сортируется отдельно (в данном случае сортировкой вставками)
4. Отсортированные корзины объединяются в результирующий массив

### Временная сложность
- **Лучший случай:** O(n + k), где k - количество корзин
- **Средний случай:** O(n + k)
- **Худший случай:** O(n²) при неравномерном распределении

---

## 2. Блинная сортировка

### Определение
Блинная сортировка использует операцию переворота префикса массива для перемещения максимальных элементов в конец.

### Код
```python
def pancake_sort(arr):
    """
    Блинная сортировка
    """
    def flip(subarray, k):
        """Переворачивает первые k элементов подмассива"""
        left = 0
        while left < k:
            subarray[left], subarray[k] = subarray[k], subarray[left]
            left += 1
            k -= 1
    
    n = len(arr)
    for curr_size in range(n, 1, -1):
        # Находим индекс максимального элемента в неотсортированной части
        max_idx = arr.index(max(arr[:curr_size]))
        
        if max_idx != curr_size - 1:
            # Переворачиваем до максимального элемента
            if max_idx != 0:
                flip(arr, max_idx)
            # Переворачиваем весь подмассив
            flip(arr, curr_size - 1)
    
    return arr

# Тестирование
if __name__ == "__main__":
    test_array = [23, 10, 20, 11, 12, 6, 7]
    print("Исходный массив:", test_array)
    sorted_array = pancake_sort(test_array.copy())
    print("Отсортированный массив:", sorted_array)
```

### Результат выдачи
```
Исходный массив: [23, 10, 20, 11, 12, 6, 7]
Отсортированный массив: [6, 7, 10, 11, 12, 20, 23]
```

### Принцип работы алгоритма
1. Находим максимальный элемент в неотсортированной части
2. Переворачиваем массив до позиции максимального элемента
3. Переворачиваем весь неотсортированный подмассив, чтобы максимальный элемент оказался на своем месте
4. Повторяем для оставшейся части массива

### Временная сложность
- **Все случаи:** O(n²)

---

## 3. Сортировка бусинами (гравитационная)

### Определение
Сортировка бусинами моделирует поведение бусин, падающих под действием гравитации.

### Код
```python
def bead_sort(arr):
    """
    Сортировка бусинами (гравитационная)
    Работает только для неотрицательных целых чисел
    """
    if any(x < 0 for x in arr):
        raise ValueError("Сортировка бусинами работает только для неотрицательных чисел")
    
    if not arr:
        return []
    
    # Создаем матрицу бусин
    max_val = max(arr)
    beads = [[0] * max_val for _ in range(len(arr))]
    
    # Расставляем бусины
    for i, value in enumerate(arr):
        for j in range(value):
            beads[i][j] = 1
    
    # "Падение" бусин под действием гравитации
    for j in range(max_val):
        # Считаем количество бусин в каждом столбце
        sum_beads = sum(beads[i][j] for i in range(len(arr)))
        # Перераспределяем бусины
        for i in range(len(arr)):
            beads[i][j] = 1 if len(arr) - i <= sum_beads else 0
    
    # Преобразуем обратно в числа
    result = [sum(row) for row in beads]
    return result

# Тестирование
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 5]
    print("Исходный массив:", test_array)
    sorted_array = bead_sort(test_array)
    print("Отсортированный массив:", sorted_array)
```

### Результат выдачи
```
Исходный массив: [3, 1, 4, 1, 5]
Отсортированный массив: [1, 1, 3, 4, 5]
```

### Принцип работы алгоритма
1. Каждое число представляется как ряд бусин
2. Бусины "падают" под действием гравитации
3. Результат считывается снизу вверх

### Временная сложность
- **Теоретическая:** O(n)
- **Практическая:** O(S), где S - сумма всех элементов

---

## 4. Поиск скачками

### Определение
Поиск скачками оптимизирует линейный поиск для отсортированных массивов, "прыгая" через блоки элементов.

### Код
```python
import math

def jump_search(arr, target):
    """
    Поиск скачками в отсортированном массиве
    """
    n = len(arr)
    step = int(math.sqrt(n))
    prev = 0
    
    # Поиск блока, содержащего целевой элемент
    while arr[min(step, n) - 1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    # Линейный поиск в найденном блоке
    while arr[prev] < target:
        prev += 1
        if prev == min(step, n):
            return -1
    
    # Проверка найденного элемента
    if arr[prev] == target:
        return prev
    
    return -1

# Тестирование
if __name__ == "__main__":
    sorted_array = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    target = 34
    print("Массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = jump_search(sorted_array, target)
    print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
```

### Результат выдачи
```
Массив: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
Поиск элемента 34
Элемент найден на позиции: 9
```

### Принцип работы алгоритма
1. Массив делится на блоки размером √n
2. Алгоритм "прыгает" по блокам, пока не найдет блок, где может находиться искомый элемент
3. В найденном блоке выполняется линейный поиск

### Временная сложность
- **Лучший случай:** O(1)
- **Средний и худший случай:** O(√n)

---

## 5. Экспоненциальный поиск

### Определение
Экспоненциальный поиск сочетает последовательный и бинарный поиск для быстрого определения диапазона.

### Код
```python
def exponential_search(arr, target):
    """
    Экспоненциальный поиск в отсортированном массиве
    """
    n = len(arr)
    
    if n == 0:
        return -1
    
    # Если элемент в начале массива
    if arr[0] == target:
        return 0
    
    # Экспоненциальное увеличение границы
    i = 1
    while i < n and arr[i] <= target:
        i *= 2
    
    # Бинарный поиск в найденном диапазоне
    left = i // 2
    right = min(i, n - 1)
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Тестирование
if __name__ == "__main__":
    sorted_array = [2, 3, 4, 10, 40, 45, 50, 60, 70, 80, 90, 100]
    target = 45
    print("Массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = exponential_search(sorted_array, target)
    print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
```

### Результат выдачи
```
Массив: [2, 3, 4, 10, 40, 45, 50, 60, 70, 80, 90, 100]
Поиск элемента 45
Элемент найден на позиции: 5
```

### Принцип работы алгоритма
1. Проверяется первый элемент
2. Граница поиска увеличивается экспоненциально (1, 2, 4, 8...)
3. В найденном диапазоне выполняется бинарный поиск

### Временная сложность
- **Все случаи:** O(log n)

---

## 6. Тернарный поиск

### Определение
Тернарный поиск делит диапазон поиска на три части и рекурсивно сужает область поиска.

### Код
```python
def ternary_search(arr, target):
    """
    Тернарный поиск в отсортированном массиве
    """
    def recursive_search(left, right):
        if left > right:
            return -1
        
        # Делим диапазон на три части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        # Проверяем граничные точки
        if arr[mid1] == target:
            return mid1
        if arr[mid2] == target:
            return mid2
        
        # Определяем в какой трети продолжать поиск
        if target < arr[mid1]:
            return recursive_search(left, mid1 - 1)
        elif target > arr[mid2]:
            return recursive_search(mid2 + 1, right)
        else:
            return recursive_search(mid1 + 1, mid2 - 1)
    
    return recursive_search(0, len(arr) - 1)

# Тестирование
if __name__ == "__main__":
    sorted_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    target = 6
    print("Массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = ternary_search(sorted_array, target)
    print(f"Элемент найден на позиции: {result}" if result != -1 else "Элемент не найден")
```

### Результат выдачи
```
Массив: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Поиск элемента 6
Элемент найден на позиции: 5
```

### Принцип работы алгоритма
1. Диапазон поиска делится на три равные части
2. Сравнивается искомый элемент с граничными точками
3. Поиск продолжается в соответствующей трети массива

### Временная сложность
- **Все случаи:** O(log₃n) = O(log n)

Все представленные алгоритмы готовы к использованию и включают подробные комментарии о принципах работы и временной сложности.
